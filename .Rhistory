#check answers
income2 <- gsscrack$income^2
summary(glm(gsscrack$crack~gsscrack$income+income2,
family=binomial(link="logit")))
beta2.wald.stat <-(beta.quadratic.par[3] - 0)^2/solve(q4.fisher)[3,3]
beta2.wald.stat
solve(q4.fisher)
q4.fisher
logistic.loglik <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
first.term <- (beta0 +beta1*x)*(1-y)
second.term <- (log(1 + exp(-beta0 - beta1*x)))
return(-sum(first.term + second.term))
}
## 2f.2
# This function should calculate the derivative of the log likelihood for the model described in #2
# It should return a vector with as many entries as there are parameters
logistic.score <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
expo <- exp(-beta0 - beta1*x)
score_beta0 <- sum(-(1-y) + (expo/(1+expo)))
score_beta1 <- sum(-x*(1-y) + (x*expo)/(1+expo))
score <- c(score_beta0, score_beta1)
return(score)
}
##testing hessian matrix
#logistic.fisher(par=beta.mle, x=gsscrack$income, y=gsscrack$crack)
## 2f.3
# This function should calculate the fisher information the model described in #2
# It should return a matrix
logistic.fisher <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
expo <- exp(-beta0 - beta1*x)
beta0.second <- sum(expo/((1+expo)^2))
beta1.second <- sum(((x^2)*expo)/((1+expo)^2))
cross.partial <- sum((x*expo)/((expo + 1)^2))
fisher <- matrix(c(beta0.second, cross.partial, cross.partial, beta1.second),
nrow=2, ncol=2)
return(fisher)
}
### 2f
## 2f.1
# This function should calculate the log likelihood for the model described in #2
# It should return a single vlaue
##make new function holding beta1 at zero to find MLE at
logistic.loglik.null <- function(par, y, x){
beta0 <- par[1]
first.term <- (beta0)*(1-y)
second.term <- (log(1 + exp(-beta0)))
return(-sum(first.term + second.term))
}
beta.null.optim <- optim(par=0, y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik.null, method = "BFGS",
control = list(fnscale = -1), hessian = TRUE)
# The asymptotic (not exact) likelihood ratio test statistic
#MLE for beta0 holding beta1 at zero
beta1.null <- beta.null.optim$par
beta1.lr.stat <- -2*(logistic.loglik.null(par=beta1.null, y=gsscrack$crack, x=gsscrack$income)-logistic.loglik(par=beta.mle, y=gsscrack$crack, x= gsscrack$income))
beta1.lr.stat
### 3e
# The score statistic
# Either form (chi-square, normal) is fine
beta1.null.vector <- c(beta1.null, 0)
score<- logistic.score(par=beta1.null.vector, y=gsscrack$crack, x=gsscrack$income)
score<- as.matrix(score)
fisher.null <- logistic.fisher(par=beta1.null.vector, x=gsscrack$income, y=gsscrack$crack)
beta1.score.stat <- t(score)%*%solve(fisher.null)%*%score
beta1.score.stat
# The p-value for the score statistic
beta1.score.pval <- 1 - pchisq(beta1.score.stat, df=1)
beta1.score.pval
### 3f
# The wald statistic
# Either form (chi-square, normal) is fine
fisher <- logistic.fisher(par=beta.mle, x=gsscrack$income, y=gsscrack$crack)
beta1.wald.stat <- ((beta.mle[2] - 0)^2)/(solve(fisher))[2,2]
# The p-value for the wald statistic
beta1.wald.pval <- 1 - pchisq(beta1.wald.stat, df=1)
beta1.wald.pval
### 3g
beta1.wald.stat
# Choose an interval and replace NULL with an expression that calculates it
# That should be something like 'c(lower,upper)'.
beta1.se.mle <- sqrt(solve(fisher)[2,2])
beta1.wald.ci <- c(beta.mle[2] - 1.96*beta1.se.mle, beta.mle[2] + 1.96*beta1.se.mle)
beta1.wald.ci
# p-value for testing beta.1 >= 0
# ge0 is short for "greater than or equal to 0"
beta.optim.onesided.1 <- optim(par=c(0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik, method = "L-BFGS-B",
lower=c(-Inf, 0),
control = list(fnscale = -1), hessian = TRUE)
beta1.lr.stat.onesided.1 <- -2*(logistic.loglik(par=beta.optim.onesided.1$par, y=gsscrack$crack, x=gsscrack$income)-logistic.loglik(par=beta.mle, y=gsscrack$crack, x= gsscrack$income))
beta1.lr.stat.onesided.1
# The p-value for the asymptotic (not exact) LR test statistic
beta1.lr.ge0.p <- 1 - pchisq(beta1.lr.stat.onesided.1, df=1)
beta1.lr.ge0.p
# p-value for testing beta.1 <= 0
# le0 is short for "less than or equal to 0"
beta.optim.onesided.2 <- optim(par=c(0, 0), y=gsscrack$crack, x=gsscrack$income,
fn=logistic.loglik, method = "L-BFGS-B", upper=c(Inf, 0),
control = list(fnscale = -1), hessian = TRUE)
beta1.lr.stat.onesided.2 <- -2*(logistic.loglik(par=beta.optim.onesided.2$par, y=gsscrack$crack, x=gsscrack$income)-logistic.loglik(par=beta.mle, y=gsscrack$crack, x= gsscrack$income))
beta1.lr.stat.onesided.2
beta1.lr.le0.p <- 1 - pchisq(beta1.lr.stat.onesided.2, df=1)
beta1.lr.le0.p
beta.glm <- summary(glm(gsscrack$crack~gsscrack$income, family=binomial(link="logit")))
beta.glm
-3.287^2
(-3.287)^2
#check for wald stat
(-3.287)^2
logistic.fisher(par=beta.mle, x=gsscrack$income, y=gsscrack$crack)
beta.quadratic.par <- beta.quadratic.optim$par
beta.quadratic.par
beta.quadratic.optim
beta.quadratic.optim <- optim(par=c(0, 0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik.quadratic,
control = list(fnscale = -1), hessian = TRUE)
beta.quadratic.optim
beta.quadratic.optim <- optim(par=c(0, 0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik.quadratic,
control = list(fnscale = -1), hessian = TRUE)
beta.quadratic.optim
beta.quadratic.par <- beta.quadratic.optim$par
beta.quadratic.par
logistic.fisher.quadratic <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
beta2 <- par[3]
expo <- exp(-beta0 - beta1*x-beta2*x^2)
beta0.second <- sum(expo/((1+expo)^2))
beta1.second <- sum(((x^2)*expo)/((1+expo)^2))
beta2.second <- sum(((x^4)*expo)/((1+expo)^2))
b0.b1.partial <- sum((x*expo)/(1+expo)^2)
b0.b2.partial <- sum((x^2*expo)/(1+expo)^2)
b1.b2.partial <- sum((x^3*expo)/(1+expo)^2)
fisher <- matrix(c(beta0.second, b0.b1.partial, b0.b2.partial, b0.b1.partial,
beta1.second, b1.b2.partial, b0.b2.partial, b1.b2.partial, beta2.second),
nrow=3, ncol=3)
return(fisher)
}
logistic.fisher.quadratic(par=beta.quadratic.par, x=gsscrack$income, y=gsscrack$crack)
q4.fisher <- logistic.fisher.quadratic(par=beta.quadratic.par, x=gsscrack$income, y=gsscrack$crack)
solve(q4.fisher)
beta2.wald.stat <-(beta.quadratic.par[3] - 0)^2/solve(q4.fisher)[3,3]
beta2.wald.stat
# The p-value for the wald statistic
beta2.wald.pval <- 1 - pchisq(beta2.wald.stat, df=1)
beta2.wald.pval
income2 <- gsscrack$income^2
summary(glm(gsscrack$crack~gsscrack$income+income2,
family=binomial(link="logit")))
1.736^2
### 4c
#find the information
logistic.fisher.quadratic <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
beta2 <- par[3]
expo <- exp(-beta0 - beta1*x-beta2*x^2)
beta0.second <- sum(expo/((1+expo)^2))
beta1.second <- sum(((x^2)*expo)/((1+expo)^2))
beta2.second <- sum(((x^4)*expo)/((1+expo)^2))
b0.b1.partial <- sum((x*expo)/(1+expo)^2)
b0.b2.partial <- sum((x^2*expo)/(1+expo)^2)
b1.b2.partial <- sum((x^3*expo)/(1+expo)^2)
fisher <- matrix(c(beta0.second, b0.b1.partial, b0.b2.partial, b0.b1.partial,
beta1.second, b1.b2.partial, b0.b2.partial, b1.b2.partial, beta2.second),
nrow=3, ncol=3)
return(fisher)
}
# The wald statistic
# Either form (chi-square, normal) is fine
#calculate new fisher
q4.fisher <- logistic.fisher.quadratic(par=beta.quadratic.par, x=gsscrack$income, y=gsscrack$crack)
beta2.wald.stat <-(beta.quadratic.par[3] - 0)^2/solve(q4.fisher)[3,3]
beta2.wald.stat
# The p-value for the wald statistic
beta2.wald.pval <- 1 - pchisq(beta2.wald.stat, df=1)
beta2.wald.pval
#check answers
income2 <- gsscrack$income^2
summary(glm(gsscrack$crack~gsscrack$income+income2,
family=binomial(link="logit")))
1.726^2
1.736^2
beta.quadratic.optim.lr.test <- optim(par=c(0, 0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik.quadratic,
control = list(fnscale = -1), lower=c(-Inf, -Inf, 0),
upper=c(Inf, Inf, 0), hessian = TRUE)
beta.quadratic.optim.lr.test <- optim(par=c(0, 0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik.quadratic,
method="L-BFGS_B",
control = list(fnscale = -1), lower=c(-Inf, -Inf, 0),
upper=c(Inf, Inf, 0), hessian = TRUE)
beta.quadratic.optim.lr.test <- optim(par=c(0, 0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik.quadratic,
method="L-BFGS-B",
control = list(fnscale = -1), lower=c(-Inf, -Inf, 0),
upper=c(Inf, Inf, 0), hessian = TRUE)
beta.quadratic.optim.lr.test <- optim(par=c(0.01, 0.01, 0.01), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik.quadratic,
method="L-BFGS-B",
control = list(fnscale = -1), lower=c(-Inf, -Inf, 0),
upper=c(Inf, Inf, 0), hessian = TRUE)
#write new function holding beta2 = 0
logistic.loglik.quadratic.null <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
first.term <- (beta0 +beta1*x )*(1-y)
second.term <- (log(1 + exp(-beta0 - beta1*x )))
return(-sum(first.term + second.term))
}
beta.quadratic.optim.null <- optim(par=c(0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik.quadratic.null,
control = list(fnscale = -1), hessian = TRUE)
beta2.lr.stat <- -2*(logistic.loglik.quadratic.null(par=beta.quadratic.optim.null$par,
y=gsscrack$crack, x=gsscrack$income)-
logistic.loglik(par=beta.quadratic.par, y=gsscrack$crack, x= gsscrack$income))
beta2.lr.stat
beta.quadratic.par
beta2.lr.stat <- -2*(logistic.loglik.quadratic.null(par=beta.quadratic.optim.null$par, y=gsscrack$crack, x=gsscrack$income) - logistic.loglik.quadratic(par=beta.quadratic.par, y=gsscrack$crack, x=gsscrack$income))
beta2.lr.stat
# The p-value for the asymptotic (not exact) LR test statistic
beta2.lr.pval <- pchisq(beta2.lr.stat, df = 1, lower.tail = F)
beta2.lr.pval
beta.quadratic.optim.null$par
beta.quadratic.par
### 4d
# The asymptotic (not exact) likelihood ratio test statistic
#write new function holding beta2 = 0
logistic.loglik.quadratic.null <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
first.term <- (beta0 +beta1*x )*(1-y)
second.term <- (log(1 + exp(-beta0 - beta1*x )))
return(-sum(first.term + second.term))
}
beta.quadratic.optim.null <- optim(par=c(0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik.quadratic.null,
control = list(fnscale = -1), hessian = TRUE)
beta2.lr.stat <- -2*(logistic.loglik.quadratic.null(par=beta.quadratic.optim.null$par, y=gsscrack$crack, x=gsscrack$income) - logistic.loglik.quadratic(par=beta.quadratic.par, y=gsscrack$crack, x=gsscrack$income))
beta2.lr.stat
# The p-value for the asymptotic (not exact) LR test statistic
beta2.lr.pval <- pchisq(beta2.lr.stat, df = 1, lower.tail = F)
beta2.lr.pval
(logistic.loglik.quadratic.null(par=beta.quadratic.optim.null$par, y=gsscrack$crack, x=gsscrack$income)
)
logistic.loglik.quadratic(par=beta.quadratic.par, y=gsscrack$crack, x=gsscrack$income)
beta2.lr.stat <- -2*log(logistic.loglik.quadratic.null(par=beta.quadratic.optim.null$par, y=gsscrack$crack, x=gsscrack$income) - logistic.loglik.quadratic(par=beta.quadratic.par, y=gsscrack$crack, x=gsscrack$income))
beta2.lr.stat <- -2*log(logistic.loglik.quadratic.null(par=beta.quadratic.optim.null$par, y=gsscrack$crack, x=gsscrack$income) - logistic.loglik.quadratic(par=beta.quadratic.par, y=gsscrack$crack, x=gsscrack$income))
beta2.lr.stat
-2*(logistic.loglik.quadratic.null(par=beta.quad.optim.null$par, y=gsscrack$crack, x=gsscrack$income) - logistic.loglik.quadratic(par=beta.quadratic.optim$par, y=gsscrack$crack, x= gsscrack$income))
-2*(logistic.loglik.quadratic.null(par=beta.quadratic.optim.null$par, y=gsscrack$crack, x=gsscrack$income) - logistic.loglik.quadratic(par=beta.quadratic.optim$par, y=gsscrack$crack, x= gsscrack$income))
# Upload to Canvas as your_name.R, replacing your_name with your actual name
# IMPORTANT:
# Note that you should be able to run your code all the way through.
# Test this by clearing the Rstudio environment (click on the broom)
# And then running from top to bottom
#
# ^^ Really! Before submitting make sure you do that.
my_name <- "Jessie Bullock"
#### Read Data ####
# Don't touch this line
# :D
gsscrack <- read.csv("http://stat111.github.io/gsscrack.csv",
header = T)
#### Problem 2 ####
### 2f
## 2f.1
# This function should calculate the log likelihood for the model described in #2
# It should return a single vlaue
logistic.loglik <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
first.term <- (beta0 +beta1*x)*(1-y)
second.term <- (log(1 + exp(-beta0 - beta1*x)))
return(-sum(first.term + second.term))
}
## 2f.2
# This function should calculate the derivative of the log likelihood for the model described in #2
# It should return a vector with as many entries as there are parameters
logistic.score <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
expo <- exp(-beta0 - beta1*x)
score_beta0 <- sum(-(1-y) + (expo/(1+expo)))
score_beta1 <- sum(-x*(1-y) + (x*expo)/(1+expo))
score <- c(score_beta0, score_beta1)
return(score)
}
##testing hessian matrix
#logistic.fisher(par=beta.mle, x=gsscrack$income, y=gsscrack$crack)
## 2f.3
# This function should calculate the fisher information the model described in #2
# It should return a matrix
logistic.fisher <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
expo <- exp(-beta0 - beta1*x)
beta0.second <- sum(expo/((1+expo)^2))
beta1.second <- sum(((x^2)*expo)/((1+expo)^2))
cross.partial <- sum((x*expo)/((expo + 1)^2))
fisher <- matrix(c(beta0.second, cross.partial, cross.partial, beta1.second),
nrow=2, ncol=2)
return(fisher)
}
#### Problem 3 ####
### 3a
# Optimize your likelihood
# Store the entire result of the optimization in 'beta.optim'
beta.optim <- optim(par=c(0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik, method = "BFGS",
control = list(fnscale = -1), hessian = TRUE)
# Store just your parameter estimate in 'beta.mle'
beta.mle <- beta.optim$par
beta.mle
# The estimated probability that someone with median income reports crack use
median.income <- median(gsscrack$income)
p.crack.median <- 1/(1+exp(-beta.mle[1] - beta.mle[2]*median.income))
p.crack.median
# The estimated probability that someone who makes $100k reports crack use
p.crack.100k <- 1/(1+exp(-beta.mle[1] - beta.mle[2]*100))
p.crack.100k
### 3d
##make new function holding beta1 at zero to find MLE at
logistic.loglik.null <- function(par, y, x){
beta0 <- par[1]
first.term <- (beta0)*(1-y)
second.term <- (log(1 + exp(-beta0)))
return(-sum(first.term + second.term))
}
beta.null.optim <- optim(par=0, y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik.null, method = "BFGS",
control = list(fnscale = -1), hessian = TRUE)
# The asymptotic (not exact) likelihood ratio test statistic
#MLE for beta0 holding beta1 at zero
beta1.null <- beta.null.optim$par
beta1.lr.stat <- -2*(logistic.loglik.null(par=beta1.null, y=gsscrack$crack, x=gsscrack$income)-logistic.loglik(par=beta.mle, y=gsscrack$crack, x= gsscrack$income))
beta1.lr.stat
# The p-value for the asymptotic (not exact) LR test statistic
beta1.lr.pval <- 1 - pchisq(beta1.lr.stat, df=1)
beta1.lr.pval
### 3e
# The score statistic
# Either form (chi-square, normal) is fine
beta1.null.vector <- c(beta1.null, 0)
score<- logistic.score(par=beta1.null.vector, y=gsscrack$crack, x=gsscrack$income)
score<- as.matrix(score)
fisher.null <- logistic.fisher(par=beta1.null.vector, x=gsscrack$income, y=gsscrack$crack)
beta1.score.stat <- t(score)%*%solve(fisher.null)%*%score
beta1.score.stat
# The p-value for the score statistic
beta1.score.pval <- 1 - pchisq(beta1.score.stat, df=1)
beta1.score.pval
### 3f
# The wald statistic
# Either form (chi-square, normal) is fine
fisher <- logistic.fisher(par=beta.mle, x=gsscrack$income, y=gsscrack$crack)
beta1.wald.stat <- ((beta.mle[2] - 0)^2)/(solve(fisher))[2,2]
beta1.wald.stat
# The p-value for the wald statistic
beta1.wald.pval <- 1 - pchisq(beta1.wald.stat, df=1)
beta1.wald.pval
### 3g
# Choose an interval and replace NULL with an expression that calculates it
# That should be something like 'c(lower,upper)'.
beta1.se.mle <- sqrt(solve(fisher)[2,2])
beta1.wald.ci <- c(beta.mle[2] - 1.96*beta1.se.mle, beta.mle[2] + 1.96*beta1.se.mle)
beta1.wald.ci
### 3i
# p-value for testing beta.1 >= 0
# ge0 is short for "greater than or equal to 0"
beta.optim.onesided.1 <- optim(par=c(0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik, method = "L-BFGS-B",
lower=c(-Inf, 0),
control = list(fnscale = -1), hessian = TRUE)
beta1.lr.stat.onesided.1 <- -2*(logistic.loglik(par=beta.optim.onesided.1$par, y=gsscrack$crack, x=gsscrack$income)-logistic.loglik(par=beta.mle, y=gsscrack$crack, x= gsscrack$income))
beta1.lr.stat.onesided.1
# The p-value for the asymptotic (not exact) LR test statistic
beta1.lr.ge0.p <- 1 - pchisq(beta1.lr.stat.onesided.1, df=1)
beta1.lr.ge0.p
# p-value for testing beta.1 <= 0
# le0 is short for "less than or equal to 0"
beta.optim.onesided.2 <- optim(par=c(0, 0), y=gsscrack$crack, x=gsscrack$income,
fn=logistic.loglik, method = "L-BFGS-B", upper=c(Inf, 0),
control = list(fnscale = -1), hessian = TRUE)
beta1.lr.stat.onesided.2 <- -2*(logistic.loglik(par=beta.optim.onesided.2$par, y=gsscrack$crack, x=gsscrack$income)-logistic.loglik(par=beta.mle, y=gsscrack$crack, x= gsscrack$income))
beta1.lr.stat.onesided.2
beta1.lr.le0.p <- 1 - pchisq(beta1.lr.stat.onesided.2, df=1)
beta1.lr.le0.p
### 3j
# Store the output of glm(...) here
beta.glm <- summary(glm(gsscrack$crack~gsscrack$income, family=binomial(link="logit")))
beta.glm
#check for wald stat
(-3.287)^2
#### Problem 4 ####
### 4a
# log likelihood for logistic regression with quadratic term
logistic.loglik.quadratic <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
beta2 <- par[3]
first.term <- (beta0 +beta1*x + beta2*x^2)*(1-y)
second.term <- (log(1 + exp(-beta0 - beta1*x - beta2*x^2)))
return(-sum(first.term + second.term))
}
# Optimize logistic.loglik.quadratic
# Store the entire result of the optimization in 'beta.quadratic.optim'
beta.quadratic.optim <- optim(par=c(0, 0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik.quadratic,
control = list(fnscale = -1), hessian = TRUE)
beta.quadratic.optim
beta.quadratic.par <- beta.quadratic.optim$par
beta.quadratic.par
### 4c
#find the information
logistic.fisher.quadratic <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
beta2 <- par[3]
expo <- exp(-beta0 - beta1*x-beta2*x^2)
beta0.second <- sum(expo/((1+expo)^2))
beta1.second <- sum(((x^2)*expo)/((1+expo)^2))
beta2.second <- sum(((x^4)*expo)/((1+expo)^2))
b0.b1.partial <- sum((x*expo)/(1+expo)^2)
b0.b2.partial <- sum((x^2*expo)/(1+expo)^2)
b1.b2.partial <- sum((x^3*expo)/(1+expo)^2)
fisher <- matrix(c(beta0.second, b0.b1.partial, b0.b2.partial, b0.b1.partial,
beta1.second, b1.b2.partial, b0.b2.partial, b1.b2.partial, beta2.second),
nrow=3, ncol=3)
return(fisher)
}
# The wald statistic
# Either form (chi-square, normal) is fine
#calculate new fisher
q4.fisher <- logistic.fisher.quadratic(par=beta.quadratic.par, x=gsscrack$income, y=gsscrack$crack)
beta2.wald.stat <-(beta.quadratic.par[3] - 0)^2/solve(q4.fisher)[3,3]
beta2.wald.stat
# The p-value for the wald statistic
beta2.wald.pval <- 1 - pchisq(beta2.wald.stat, df=1)
beta2.wald.pval
#check answers
income2 <- gsscrack$income^2
summary(glm(gsscrack$crack~gsscrack$income+income2,
family=binomial(link="logit")))
#check wald stat
1.736^2
### 4d
# The asymptotic (not exact) likelihood ratio test statistic
#write new function holding beta2 = 0
logistic.loglik.quadratic.null <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
first.term <- (beta0 +beta1*x )*(1-y)
second.term <- (log(1 + exp(-beta0 - beta1*x )))
return(-sum(first.term + second.term))
}
beta.quadratic.optim.null <- optim(par=c(0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik.quadratic.null,
control = list(fnscale = -1), hessian = TRUE)
beta2.lr.stat <- -2*(logistic.loglik.quadratic.null(par=beta.quadratic.optim.null$par, y=gsscrack$crack, x=gsscrack$income) - logistic.loglik.quadratic(par=beta.quadratic.par, y=gsscrack$crack, x=gsscrack$income))
beta2.lr.stat
# The p-value for the asymptotic (not exact) LR test statistic
beta2.lr.pval <- pchisq(beta2.lr.stat, df = 1, lower.tail = F)
beta2.lr.pval
## 4f (extra credit)
# Replace these with the real values if you try this part
# Otherwise leave them untouched
beta2.score.stat <- 0
beta2.score.pval <- -1
gsscrack <- read.csv("http://stat111.github.io/gsscrack.csv",header = T)
logistic.loglik <- function(par,y,x){
return (sum((y-1)*(par[1]+par[2]*x)-log(1+exp(-par[1]-par[2]*x))))
}
logistic.fisher.jessie <- function(par, y, x){
beta0 <- par[1]
beta1 <- par[2]
expo <- exp(-beta0 - beta1*x)
beta0.second <- sum(expo/((1+expo)^2))
beta1.second <- sum((x^2*expo)/((1+expo)^2))
cross.partial <- sum((x*expo)/((expo + 1)^2))
fisher <- matrix(c(beta0.second, cross.partial, cross.partial, beta1.second),
nrow=2, ncol=2)
return(fisher)
}
beta.optim = optim(c(1,1),logistic.loglik,control=list(fnscale=-1),
y=gsscrack$crack,x=gsscrack$income,hessian = TRUE)
beta.mle = beta.optim$par
logistic.fisher.jessie(par=beta.mle, x=gsscrack$income, y=gsscrack$crack)
beta.optim <- optim(par=c(0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik,
control = list(fnscale = -1), hessian = TRUE)
# Store just your parameter estimate in 'beta.mle'
beta.optim
beta.optim <- optim(par=c(0, 0), y=gsscrack$crack,
x=gsscrack$income, fn=logistic.loglik,
control = list(fnscale = -1), hessian = TRUE)
beta.optim
tab567.dat <- read.dta('01_Data/REPLICATION_APSR_2014_BRQ/REPLICATION_TABLE_5_6_7_APSR_2014_BRQ.dta')
setwd('~/Google Drive/GOV_2001_REPLICATION/')
library(foreign)
tab567.dat <- read.dta('01_Data/REPLICATION_APSR_2014_BRQ/REPLICATION_TABLE_5_6_7_APSR_2014_BRQ.dta')
View(tab567.dat)
tab.e(tab567.dat$gridcity1400)
table(tab567.dat$gridcity1400)
table(tab567.dat$JurisHierac)
